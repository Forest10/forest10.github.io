---
title: 高性能MySql之Schema与数据类型优化
date: 2018-07-17 20:51:58
tags: [mysql]
categories: [sql,mysql]
---


### 1.1 选择优化的数据类型

- 更小的通常更好
 - (例如只存0-200,tinyint unsigned更好)
 
 - 简单就好,整型比字符操作代价低,因为字符集和校对规则使得字符的比较比整型更加复杂
 
		 一是使用Mysql内建的类型而不是字符串来存储日期和时间(date,time,datetime)
		 二是使用整型存储IP地址 
- DATETIME和TIMESTAMP都可以存储相同类型的数据:时间和日期,精确到秒,然而TIMESTAMP只使用DATETIME一半的存储,但是TIMESTAMP允许的时间范围要小的多



### 1.2 实数类型

- 浮点类型在存储同样范围的值时,通常比DECIMAL使用更少的空间,FLOAT使用4个字节存储,DOUBLE使用8个字节,MYSQL使用DOUBLE作为内部浮点计算的类型

> 因为需要额外的空间和计算开销.数据量比较大的时候,使用BIGINT代替DECIMAL,将需要存储的货币单位根据小数的位数乘以相应的倍数即可


### 1.3 字符串类型
> 字符创长度定义是字符数,不是字节数

- VACHAR
	- VARCHAR需要使用1或2个额外字节记录字符串的长度:如果列的最大长度<=255字节,则使用1个字节表示.否则使用2个字节.

	- VARCHAR节省存储空间,但是如果一个行占用的空间增长,并且在页内没有更多的空间存储,这种情况下,不同的存储引擎处理不一样,MyISAM会将行拆成不同的片段存储,InnoDB需要分裂页来使行可以放入页内. 

- CHAR
	- 定长的
	
	- MYSQL会删除所有的末尾空格


### 1.4 日期和时间类型


- DATETIME 
	- 保存从1001到9999年,精度为秒.它把日期和时间封装到YYYYMMDDHHMMSS的整数中,与时区无关,使用8个字节存储空间.


### 1.4 日期和时间类型


- DATETIME 
	- 保存从1001到9999年,精度为秒.它把日期和时间封装到YYYYMMDDHHMMSS的整数中,与时区无关,使用8个字节存储空间.

- TIMESTAMP
  	- 保存了从1970年1月1日午夜以来的秒数,和UNIX时间戳相同,它只使用4个字节存储空间.只能表示1970-2038
  	
  	- TIMESTAMP有DATETIME没有的特殊属性,默认情况下,如果插入时没有指定第一个TIMESTAMP列的值,MYSQL则设置这个列的值为当前时间.在插入一行记录时,MYSQL也会更新第一个TIMESTAMP列的值(除非在UPDATE语句中明确指定了值).最后TIMESTAMP默认为NOT NULL

  	
  	
### 1.5 位数据类型	

- BIT
  - 在MYSQL 5.0之前,BIT是TINYINT的同义词.5.0之后就是一个特性完全不同的数据类型.可以使用BIT列在一列中存储一个或多个true/false值.BIT(1)定义一个包含单个位的字段.BIT(2)存储2个位.以此类推,BIT列最大长度为64个位.
  - MYSQL把BIT当字符串类型而不是数字类型.当检索BIT(1)的值时,结果是包含二进制0或1值的字符串.而不是ASCII码的"0"或"1",然而,在数字上下文的场景中检索时,结果将是把位字符串转换成的数字.如果需要和另外的值比较结果,一定要记得!!! 例如,如果存储一个值b'00111001'(二进制等于57)到BIT(8)的列并检索它,得到的是字符码为57的字符串.也即是说得到ASCII码为57的字符'9',但是在数字场景下,得到的是数字57.	

### 2.0 MySQL schema设计中的陷阱

- 太多的列
	- MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过该行缓冲格式拷贝数据,然后在服务器层将缓冲内容解码成各个列.这个代价是非常高的.MyISAM的定长行结构实际上与服务器层的行结构正好匹配,所以不需要转换.然而MyISAM的变长行结构和InnoDB的行结构则总需要转换,转换的代价依赖列的数量.

	
### 2.1 范式和反范式

- 范式化的设计缺点是通常需要关联,不但代价昂贵,还可能使一些索引策略失效.

- 反范式化的schema因为所有数据都在一张表上,在面对大部分查询最差的情况---即使表没有使用索引--全表扫描.当数据比内存大时这可能比关联还要快,因为这避免了随机I/O